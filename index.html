<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Sunken Garden | An Interactive Ecological Map</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Crimson+Text:ital,wght@0,400;1,400&display=swap" rel="stylesheet" />
  <style>
/* Final polished styling - Ambient & Ecological */
* { 
  box-sizing: border-box; 
}

body {
  margin: 0;
  font-family: 'Inter', sans-serif;
  background: #f4f1e9; /* Lighter Parchment */
  color: #4a443a; /* Dark, earthy brown text */
  overflow: hidden;
  min-height: 100vh;
}

/* UI Panels (Header, Legend, etc.) */
#header-container, #legend, #plant-info, #search-container {
  position: fixed;
  background: rgba(245, 245, 220, 0.85); /* Semi-transparent beige */
  backdrop-filter: blur(8px);
  border: 1px solid rgba(139, 125, 107, 0.2); /* Soft brown border */
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
  padding: 20px;
}

#header-container { top: 24px; left: 24px; max-width: 320px; z-index: 102; }
#legend { top: 24px; right: 24px; max-width: 220px; max-height: calc(100vh - 48px); overflow-y: auto; z-index: 102; transition: all 0.3s ease; }
#search-container { bottom: 24px; left: 24px; min-width: 300px; padding: 12px; z-index: 101; }
#plant-info { top: 24px; right: 24px; max-width: 350px; max-height: calc(100vh - 48px); overflow-y: auto; z-index: 103; }

/* Typography */
#title { margin: 0 0 8px 0; font-family: 'Crimson Text', serif; font-size: 1.8rem; font-weight: 400; }
#title a {
  color: #5d5547;
  text-decoration: none;
  transition: color 0.2s ease;
}
#title a:hover {
    color: #003399; /* COA Blue on hover */
}
#title a.garden-link {
    font-style: italic;
}

#subtitle {
  font-size: 0.95rem;
  line-height: 1.6;
  opacity: 0.9;
  margin: 0 0 16px 0;
  font-family: 'Crimson Text', serif;
  color: #6b6355;
}

#subtitle a {
    color: #8b7d6b;
    text-decoration: underline;
    transition: color 0.2s ease;
}
#subtitle a:hover {
    color: #003399;
}


/* Controls */
.controls-container { display: flex; flex-direction: column; gap: 8px; } /* Changed to column */
.control-btn {
  background: rgba(139, 125, 107, 0.1);
  border: 1px solid rgba(139, 125, 107, 0.3);
  border-radius: 6px;
  color: #5d5547;
  cursor: pointer;
  padding: 10px 16px;
  font-size: 0.9rem;
  transition: all 0.2s ease;
  width: 100%; /* Make buttons fill container */
  text-align: center;
}
.control-btn:hover {
  background: rgba(139, 125, 107, 0.2);
  border-color: rgba(139, 125, 107, 0.5);
}
.control-btn:active {
    transform: scale(0.95);
    background: rgba(139, 125, 107, 0.25);
}

.control-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
    margin-top: 8px;
}
.control-row label {
    font-size: 0.9rem;
    color: #5d5547;
    flex-shrink: 0;
}
#color-by-select {
    width: 100%;
    background: rgba(255, 255, 255, 0.5);
    border: 1px solid rgba(139, 125, 107, 0.3);
    border-radius: 6px;
    color: #5d5547;
    padding: 8px 12px;
    font-size: 0.9rem;
    transition: all 0.2s ease;
}
#color-by-select:focus {
    outline: none;
    border-color: rgba(139, 125, 107, 0.5);
    background: rgba(255, 255, 255, 0.8);
}


.toggle-controls-container { margin-top: 16px; display: flex; flex-direction: column; gap: 12px; }
.toggle-row { display: flex; justify-content: space-between; align-items: center; }
.toggle-row label { font-size: 0.9rem; color: #5d5547; }
.switch { position: relative; display: inline-block; width: 40px; height: 22px; }
.switch input { opacity: 0; width: 0; height: 0; }
.slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(139, 125, 107, 0.3); transition: .4s; border-radius: 22px; }
.slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
input:checked + .slider { background-color: #669966; }
input:checked + .slider:before { transform: translateX(18px); }

/* Legend Styling */
#legend.hidden { opacity: 0; pointer-events: none; transform: translateX(20px); }
#legend.multi-column { max-width: 400px; }
#legend.multi-column #legend-items { column-count: 2; column-gap: 24px; }
.legend-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(139, 125, 107, 0.2); margin-bottom: 12px; padding-bottom: 8px; }
#legend h3 { margin: 0; font-size: 1rem; font-weight: 500; color: #5d5547; }
#legend-minify-toggle { background: none; border: none; cursor: pointer; padding: 4px; }
#legend-minify-toggle svg { width: 16px; height: 16px; stroke: #9c8f7d; transition: all 0.2s ease; }
#legend-minify-toggle:hover svg { stroke: #5d5547; }
#legend.minified #legend-minify-toggle svg { transform: rotate(180deg); }
#legend.minified { max-height: 50px; width: auto; min-width: 150px; padding: 12px 20px; overflow: hidden; }
#legend.minified .legend-header { margin-bottom: 0; border-bottom: none; padding-bottom: 0; }
#legend.minified h3 { padding-bottom: 0; }
#legend.minified #legend-items { display: none; }
.legend-item { display: flex; align-items: center; margin-bottom: 8px; font-size: 0.85rem; color: #6b6355; cursor: pointer; transition: all 0.2s ease; break-inside: avoid; border-radius: 4px; padding: 2px 4px; margin: 0 -4px 8px -4px; }
.legend-item:hover { background-color: rgba(139, 125, 107, 0.1); }
.legend-item.highlighted { font-weight: 600; color: #3b372f; background-color: rgba(139, 125, 107, 0.15); }
.legend-color-swatch { width: 12px; height: 12px; border-radius: 50%; margin-right: 10px; flex-shrink: 0; border: 1px solid rgba(0, 0, 0, 0.1); }

/* Info Panel Styling */
#plant-info { 
    transform: translateX(100%); 
    opacity: 0; 
    pointer-events: none; 
    transition: all 0.3s ease; 
}
#plant-info.visible { transform: translateX(0); opacity: 1; pointer-events: auto; }

#plant-info::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 30px;
    background: linear-gradient(to top, rgba(245, 245, 220, 1), rgba(245, 245, 220, 0));
    pointer-events: none;
    border-bottom-left-radius: 8px;
    border-bottom-right-radius: 8px;
    opacity: 0;
    transition: opacity 0.2s ease;
}
#plant-info.is-scrollable::after {
    opacity: 1;
}

.info-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(139, 125, 107, 0.2); margin-bottom: 16px; }
#plant-info h3 { color: #5d5547; margin: 0; padding-bottom: 8px; flex-grow: 1; display: flex; align-items: center; }
#plant-info .common-name-native { font-size: 0.9rem; color: #8b7d6b; font-style: italic; }
#plant-info .latin-name { font-family: 'Crimson Text', serif; font-style: italic; font-size: 1rem; color: #8b7d6b; margin-top: -4px; margin-bottom: 8px; }
.info-close-btn { background: transparent; border: none; cursor: pointer; padding: 0; width: 24px; height: 24px; flex-shrink: 0; margin-left: 16px; }
.info-close-btn svg { width: 100%; height: 100%; stroke: #9c8f7d; transition: stroke 0.2s ease; }
.info-close-btn:hover svg { stroke: #5d5547; }
.info-section h4 { font-size: 1rem; font-weight: 600; color: #5d5547; margin: 16px 0 8px 0; border-bottom: 1px solid rgba(139, 125, 107, 0.1); padding-bottom: 4px; }
.info-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 16px; margin-bottom: 12px; }
.info-item { display: flex; align-items: center; gap: 8px; }
.info-item-icon { width: 20px; height: 20px; flex-shrink: 0; stroke: #8b7d6b; fill: none; stroke-width: 1.5; }
.info-item-text .info-label { font-size: 0.8rem; color: #8b7d6b; margin: 0; }
.info-item-text .info-content { font-size: 0.9rem; color: #6b6355; margin: 0; }
.info-label { color: #8b7d6b; font-weight: 500; margin-bottom: 4px; }
.info-label.distant-neighbors-label { margin-top: 16px; }
.info-content { color: #6b6355; margin-bottom: 12px; }
.info-content.poetic { font-family: 'Crimson Text', serif; font-size: 1.1rem; font-style: italic; line-height: 1.6; margin-bottom: 20px; }
.nearby-species-list { padding-left: 0; list-style: none; margin: 0; }
.nearby-species-list li { 
  color: #6b6355; 
  margin-bottom: 6px; 
  cursor: pointer; 
  transition: color 0.2s ease; 
  display: flex; 
  align-items: center;
}
.nearby-species-list li:hover { color: #3b372f; }
.nearby-species-swatch {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 8px;
    flex-shrink: 0;
    border: 1px solid rgba(0,0,0,0.1);
}


/* Search Styling */
#search-results { position: absolute; bottom: calc(100% + 4px); left: 0; right: 0; background: rgba(245, 245, 220, 0.95); border: 1px solid rgba(139, 125, 107, 0.2); border-radius: 8px; max-height: 200px; overflow-y: auto; }
#search-results:empty { display: none; }
.search-result-item { padding: 12px 16px; cursor: pointer; color: #6b6355; font-family: 'Crimson Text', serif; font-size: 1rem; transition: background-color 0.2s ease; }
.search-result-item:hover { background-color: rgba(139, 125, 107, 0.1); }
#search-input { width: 100%; background: rgba(255, 255, 255, 0.5); border: 1px solid rgba(139, 125, 107, 0.3); border-radius: 6px; color: #5d5547; padding: 12px 16px; font-size: 1rem; font-family: 'Crimson Text', serif; transition: all 0.2s ease; }
#search-input::placeholder { color: rgba(93, 85, 71, 0.6); font-style: italic; }
#search-input:focus { outline: none; border-color: rgba(139, 125, 107, 0.5); background: rgba(255, 255, 255, 0.8); }

/* Garden Canvas & Map */
#garden-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; cursor: grab; }
#garden-container.panning { cursor: grabbing; }
#garden-canvas { width: 100%; height: 100%; transform-origin: 0 0; }
#garden-map { position: absolute; z-index: 0; pointer-events: none; opacity: 0.4; transition: opacity 0.3s ease; }
#garden-map.hidden { opacity: 0; }
body.paths-hidden.plants-hidden #garden-map:not(.hidden) { 
    opacity: 0.8; 
}

/* Network & Plant Nodes */
.network-node {
  position: absolute; width: 8px; height: 8px; background: #996633; border: 2px solid rgba(255, 255, 255, 0.7); box-shadow: 0 0 6px rgba(0,0,0,0.3); transform: translate(-50%, -50%); border-radius: 50%; cursor: pointer; transition: all 0.3s ease; z-index: 5;
}
.network-node:active {
    transform: translate(-50%, -50%) scale(2.2);
}
.network-node.highlighted, .network-node:hover { background: #A0522D; transform: translate(-50%, -50%) scale(2.5); z-index: 20; }
body.paths-hidden .network-node, body.paths-hidden .connection-line { display: none; }

.plant-node {
  position: absolute; width: 15px; height: 15px; border: 3px solid rgba(74, 68, 58, 0.4); box-shadow: 0 0 8px rgba(0,0,0,0.3); transform: translate(-50%, -50%); border-radius: 50%; cursor: pointer; transition: all 0.3s ease; z-index: 10;
}
.plant-node.uncolored {
    background-color: rgba(74, 68, 58, 0.1);
    border-color: rgba(74, 68, 58, 0.2);
    opacity: 0.7;
}
.plant-node:active {
    transform: translate(-50%, -50%) scale(1.3);
}
.plant-node:hover { transform: translate(-50%, -50%) scale(1.5); border-color: rgba(74, 68, 58, 0.8); z-index: 20; }
.plant-node.selected { transform: translate(-50%, -50%) scale(2.2); border-color: #fff; box-shadow: 0 0 16px rgba(0,0,0,0.5); z-index: 25; }
body.plants-hidden .plant-node { display: none; }

/* Connection Lines */
.connection-line {
  position: absolute; height: 2px; background: rgba(153, 102, 51, 0.4); z-index: 1; transform-origin: left center; pointer-events: none;
}
.connection-line.highlighted { height: 3px; background: #A0522D; box-shadow: 0 0 8px #A0522D; }

/* Radius Visualization */
.radius-disk {
  position: absolute;
  border-radius: 50%;
  pointer-events: none;
  z-index: 4;
  transform: translate(-50%, -50%);
}
.radius-disk.close {
  background: rgba(102, 153, 102, 0.2);
  border: 2px solid rgba(102, 153, 102, 0.5);
}
.radius-disk.far {
  background: rgba(102, 153, 102, 0.1);
  border: 2px solid rgba(102, 153, 102, 0.4);
}

/* Tutorial & About Modals */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 200;
  display: flex;
  justify-content: center;
  align-items: center;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}
.modal-overlay.visible {
  opacity: 1;
  pointer-events: auto;
}
.modal {
  background: #f4f1e9;
  padding: 32px;
  border-radius: 8px;
  max-width: 500px;
  width: calc(100% - 48px);
  box-shadow: 0 10px 30px rgba(0,0,0,0.2);
  font-family: 'Crimson Text', serif;
}
.modal h2 {
  font-size: 1.8rem;
  color: #5d5547;
  margin-top: 0;
}
.modal p {
  font-family: 'Inter', sans-serif;
  font-size: 1rem;
  color: #6b6355;
  line-height: 1.6;
}
.modal ul {
  list-style: none;
  padding: 0;
  font-family: 'Inter', sans-serif;
  font-size: 0.95rem;
  color: #6b6355;
  margin-top: 24px;
}
.modal li {
  margin-bottom: 12px;
  line-height: 1.5;
}
.modal .modal-button {
  background: #A0522D;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 1rem;
  font-family: 'Inter', sans-serif;
  display: block;
  margin: 24px auto 0;
  transition: background-color 0.2s ease, transform 0.1s ease;
  text-decoration: none;
  text-align: center;
}
.modal .modal-button:hover {
  background: #8B4513;
}
.modal .modal-button:active {
    transform: scale(0.95);
}


/* Mobile Toggles */
#mobile-menu-toggle, #legend-toggle { display: none; }

/* Responsive & Accessibility */
@media (max-width: 768px) {
  #header-container {
    background: transparent;
    backdrop-filter: none;
    border: none;
    box-shadow: none;
    padding: 0;
    width: auto;
  }
  #header-content {
    position: fixed;
    top: 0;
    left: 0;
    width: 300px;
    height: 100%;
    padding: 80px 24px 24px 24px;
    background: rgba(245, 245, 220, 0.95);
    backdrop-filter: blur(8px);
    border-right: 1px solid rgba(139, 125, 107, 0.2);
    transform: translateX(-100%);
    transition: transform 0.3s ease-in-out;
    z-index: 103;
  }
  #header-container.menu-open #header-content {
    transform: translateX(0);
  }
  #mobile-menu-toggle, #legend-toggle {
    display: block;
    position: fixed;
    top: 24px;
    background: rgba(245, 245, 220, 0.85);
    backdrop-filter: blur(8px);
    border: 1px solid rgba(139, 125, 107, 0.2);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 10px;
    cursor: pointer;
    transition: transform 0.1s ease;
  }
  #mobile-menu-toggle { 
    left: 24px; 
    z-index: 101;
  }
  #header-container.menu-open + #mobile-menu-toggle {
      z-index: 103;
  }
  #legend-toggle { 
    right: 24px; 
    z-index: 103;
  }
  #legend {
    right: 24px;
    left: auto;
    max-width: calc(100% - 96px); /* Prevent overlap with menu button */
    max-height: calc(100vh - 110px); /* Prevent overlap with search bar */
  }
  #legend.mobile-hidden {
    transform: translateX(calc(100% + 32px));
    opacity: 0;
    pointer-events: none;
  }
  #legend.multi-column #legend-items {
      column-count: 1;
  }
  #search-container {
    left: 24px; right: 24px; max-width: none;
  }
  #plant-info { 
    left: 24px; 
    right: 24px; 
    max-width: none; 
    max-height: calc(100vh - 110px); /* Prevent overlap with search bar */
  }
  .modal {
    padding: 24px;
    max-height: calc(100vh - 48px);
    overflow-y: auto;
  }
  .modal h2 {
      font-size: 1.5rem;
  }
  .modal p, .modal li {
      font-size: 0.9rem;
  }
  .network-node {
      width: 12px;
      height: 12px;
  }
  .plant-node {
      width: 20px;
      height: 20px;
  }
}
@media (prefers-reduced-motion: reduce) {
  * { animation-duration: 0.01ms !important; transition-duration: 0.1s !important; }
}
.control-btn:focus, #search-input:focus, .plant-node:focus, .network-node:focus {
  outline: 2px solid #003399; outline-offset: 2px;
}
  </style>
</head>
<body>
  <div id="header-container">
    <div id="header-content">
        <h1 id="title">
            <a href="https://www.coa.edu/" target="_blank">The College of the Atlantic</a> 
            <a href="https://www.coa.edu/live/files/841-appendix-1-sunken-garden-brochure-pdf" target="_blank" class="garden-link">Sunken Garden</a>
        </h1>
        <p id="subtitle">
            Explore a living map of native plants that nourish pollinators, wildlife, and the human spirit.
        </p>
        <div class="controls-container">
            <button class="control-btn" id="reset-view">Reset View</button>
            <div class="control-row">
                <label for="color-by-select">Color by:</label>
                <select id="color-by-select"></select>
            </div>
        </div>
        <div class="toggle-controls-container">
            <div class="toggle-row">
                <label for="toggle-map">Show Map</label>
                <label class="switch">
                    <input type="checkbox" id="toggle-map" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="toggle-row">
                <label for="toggle-paths">Show Paths</label>
                <label class="switch">
                    <input type="checkbox" id="toggle-paths" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="toggle-row">
                <label for="toggle-plants">Show Plants</label>
                <label class="switch">
                    <input type="checkbox" id="toggle-plants" checked>
                    <span class="slider"></span>
                </label>
            </div>
        </div>
        <button class="control-btn" id="about-btn" style="margin-top: 16px;">About this Map</button>
    </div>
  </div>

  <button id="mobile-menu-toggle">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M4 6H20M4 12H20M4 18H20" stroke="#4a443a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
  </button>

  <button id="legend-toggle">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 21C16.9706 21 21 16.9706 21 12C21 7.02944 16.9706 3 12 3C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21Z" stroke="#4a443a" stroke-width="2" stroke-miterlimit="10"/>
          <path d="M12 16.5C14.4853 16.5 16.5 14.4853 16.5 12C16.5 9.51472 14.4853 7.5 12 7.5C9.51472 7.5 7.5 9.51472 7.5 12C7.5 14.4853 9.51472 16.5 12 16.5Z" stroke="#4a443a" stroke-width="2" stroke-miterlimit="10"/>
          <path d="M12 3V21" stroke="#4a443a" stroke-width="2" stroke-miterlimit="10"/>
      </svg>
  </button>

  <div id="legend">
    <div class="legend-header">
        <h3>Legend</h3>
        <button id="legend-minify-toggle">
            <svg viewBox="0 0 24 24"><path d="M18 15l-6-6-6 6"/></svg>
        </button>
    </div>
    <div id="legend-items"></div>
  </div>
  <div id="search-container">
    <div id="search-results"></div>
    <input type="text" id="search-input" placeholder="Seek botanical wisdom..." />
  </div>
  <div id="garden-container">
    <div id="garden-canvas">
      <img id="garden-map" alt="Map of the Sunken Garden" style="display: none;">
    </div>
  </div>
  <div id="plant-info">
    <div class="info-header">
        <h3 id="plant-name">Select a specimen to explore</h3>
        <button id="close-info" class="info-close-btn">
            <svg viewBox="0 0 24 24" fill="none" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
    </div>
    <div id="plant-info-details"></div>
  </div>
  
  <div id="tutorial-overlay" class="modal-overlay">
      <div id="tutorial-modal" class="modal">
          <h2>Welcome to the Sunken Garden</h2>
          <p>Here are a few ways to explore:</p>
          <ul>
              <li><strong>Pan & Zoom:</strong> Click and drag to move the map. Use your scroll wheel to zoom in and out.</li>
              <li><strong>Explore Plants:</strong> Click on any colored circle to learn about a specific plant species.</li>
              <li><strong>Discover Connections:</strong> Click on a path node (the small brown circles) to see which plants live nearby.</li>
              <li><strong>Search:</strong> Use the search bar at the bottom left to find a specific plant by name.</li>
              <li><strong>Visualize Data:</strong> Use the "Color by" dropdown to see the garden organized by different categories.</li>
          </ul>
          <button id="close-tutorial" class="modal-button">Begin Exploring</button>
      </div>
  </div>

  <div id="about-overlay" class="modal-overlay">
      <div id="about-modal" class="modal">
          <h2>About this Map</h2>
          <p>This interactive map was created by Phileas Dazeley-Gaist (COA '23) on a whim as a passion project. It's designed to encourage people to connect with the plant life in the COA Sunken Garden and celebrate the beauty of this unique space.</p>
          <p>The map and initial plant labels are based on the <a href="https://www.coa.edu/live/files/841-appendix-1-sunken-garden-brochure-pdf" target="_blank">Sunken Garden Brochure</a>. The detailed plant information was sourced from Yaniv Korman's charmingly and lovingly edited Edible Plant List of the Sunken Garden booklet.</p>
          <p>If you find this map useful or inspiring, please consider supporting its continued development or checking out more of my work below.</p>
          <a href="https://phileasdg.github.io/" target="_blank" class="modal-button">Personal Blog</a>
          <a href="https://www.paypal.com/donate/?business=K74DYULZ2J&no_recurring=0&item_name=Buy+me+a+coffee+%3AD&currency_code=USD" target="_blank" id="donate-button" class="modal-button" style="margin-top: 12px;">Buy me a coffee</a>
          <button id="close-about" class="modal-button" style="background-color: #6b6355; margin-top: 12px;">Close</button>
      </div>
  </div>

<script>
// Global data variables
let edgeList = [];
let networkPositions = {};
let plantLabels = {};
let plantData = {};

// UI state
let scale = 1;
let translateX = 0;
let translateY = 0;
let isPanning = false;
let lastPanPoint = { x: 0, y: 0 };
let initialPinchDistance = null;
let colorByKey = 'species';
let speciesColorMap = {};
let dynamicColorMaps = {};
let radiusDisks = []; // To hold the visual radius disks
let selectedNetworkNodeId = null; // Track selected path node
let wasLegendVisible = false; // Track legend state before opening info panel

// DOM element collections
const plantNodes = [];
const networkNodes = [];
const connections = [];
let adjacencyList = {};

// NOTE: These radii are in the map's coordinate system (pixels on the map image).
// 172px was determined to be the equivalent of 10ft on the map.
const CLOSE_RADIUS = 172; // 10ft
const FAR_RADIUS = 344;   // 20ft

// More poetic messages for path nodes
const pathMessages = {
    degree1: [
        { text: 'A threshold to stillness, where the garden path begins its quiet story.', weight: 5 },
        { text: 'Here, the world recedes, leaving only the scent of earth and leaf.', weight: 5 },
        { text: 'An entrance to wonder, or a gentle farewell to a hidden world.', weight: 5 },
        { text: 'From this quiet edge, the garden whispers its first invitation.', weight: 2 },
        { text: 'A secret gate, guarded by moss and shadow.', weight: 1 }
    ],
    degree2: [
        { text: 'A moment of pause on a flowing current of stone and soil.', weight: 5 },
        { text: 'The journey continuesâ€¦ what new light filters through the canopy ahead?', weight: 5 },
        { text: 'The garden breathes around this tranquil point, a gentle, living sigh.', weight: 5 },
        { text: 'Listen. Can you hear the rustle of ferns, the hum of unseen wings?', weight: 2 },
        { text: 'Follow the stones; they remember the way, even when we forget.', weight: 1 }
    ],
    degree3: [
        { text: 'A quiet convergence of stone and soil, where one journey ends and another begins.', weight: 5 },
        { text: 'Here, the garden holds its breath, offering a choice between familiar paths and unseen possibilities.', weight: 5 },
        { text: `A gathering of ways, where ${'${degree}'} currents of scent and color merge and flow.`, weight: 5 },
        { text: 'Here, the garden offers a choice. Not of direction, but of daydream.', weight: 2 },
        { text: 'A crossroads of chlorophyll and contemplation. Which memory will you follow?', weight: 1 }
    ]
};

const ICONS = {
    sun: `<svg class="info-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2m0 16v2M4.93 4.93l1.41 1.41m11.32 11.32l1.41 1.41M2 12h2m16 0h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"></path></svg>`,
    water: `<svg class="info-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22a7 7 0 0 0 7-7c0-3.87-7-13-7-13s-7 9.13-7 13a7 7 0 0 0 7 7z"></path></svg>`,
    height: `<svg class="info-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20V4m-4 4l4-4 4 4m-8 8l4 4 4-4"></path></svg>`,
    spread: `<svg class="info-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12h16M8 8l-4 4 4 4m8-8l4 4-4 4"></path></svg>`,
    bloom: `<svg class="info-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5a3 3 0 0 1 3 3v0a3 3 0 0 1-6 0v0a3 3 0 0 1 3-3z"/><path d="M19 12a3 3 0 0 1-3 3h0a3 3 0 0 1 0-6h0a3 3 0 0 1 3 3z"/><path d="M12 19a3 3 0 0 1-3-3h0a3 3 0 0 1 6 0h0a3 3 0 0 1-3 3z"/><path d="M5 12a3 3 0 0 1 3-3h0a3 3 0 0 1 0 6h0a3 3 0 0 1-3-3z"/><circle cx="12" cy="12" r="1"/></svg>`,
    harvest: `<svg class="info-item-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v20M8 8l4 4 4-4M8 14l4 4 4-4"/></svg>`
};

function getRandomMessage(messages) {
    const totalWeight = messages.reduce((sum, msg) => sum + msg.weight, 0);
    let random = Math.random() * totalWeight;
    for (const msg of messages) {
        if (random < msg.weight) return msg.text;
        random -= msg.weight;
    }
    return messages[0].text; // Fallback
}


// Load all data from JSON files
async function loadData() {
  console.log('Loading data files...');
  try {
    const [edgeResponse, positionsResponse, labelsResponse, dataResponse] = await Promise.all([
      fetch('./data/edge-list.json'),
      fetch('./data/vertex-positions.json'),
      fetch('./data/plant-labels.json'),
      fetch('./data/plant-data.json') // This now fetches your detailed plant data
    ]);

    if (!edgeResponse.ok || !positionsResponse.ok || !labelsResponse.ok || !dataResponse.ok) {
      throw new Error(`One or more data files failed to load`);
    }

    edgeList = await edgeResponse.json();
    networkPositions = await positionsResponse.json();
    plantLabels = await labelsResponse.json();
    plantData = await dataResponse.json();
    
    console.log('Data loaded successfully from JSON files');
    
  } catch (error) {
    console.error('Error loading JSON files (this is expected when running locally):', error);
    console.log('Loading fallback demo data...');
    
    // Fallback data remains for local testing without a server
    edgeList = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [1, 6], [2, 7], [3, 8], [4, 9], [5, 10]];
    networkPositions = {
      "1": [100, 100], "2": [200, 120], "3": [300, 100], "4": [400, 120], "5": [500, 100],
      "6": [150, 200], "7": [250, 220], "8": [350, 200], "9": [450, 220], "10": [550, 200]
    };
    plantLabels = {
      "Demo Plant A": [[120, 150], [180, 170]],
      "Demo Plant B": [[320, 150], [380, 170]],
      "Demo Plant C": [[520, 150]]
    };
    plantData = {
      "Demo Plant A": { latin_name: "Demo plantus a", category: "Shrubs", "Flowering Season": "Spring", benefits: "Demo benefits" },
      "Demo Plant B": { latin_name: "Demo plantus b", category: "Perennials", "Soil Preference": "Moist, well-draining" },
      "Demo Plant C": { latin_name: "Demo plantus c", category: "Trees", "Mature Height": "30-50 feet", care: "Demo care instructions" }
    };
    
    console.log('Fallback data loaded successfully');
  }
  
  adjacencyList = {};
  edgeList.forEach(([a, b]) => {
    if (!adjacencyList[a]) adjacencyList[a] = [];
    if (!adjacencyList[b]) adjacencyList[b] = [];
    adjacencyList[a].push(b);
    adjacencyList[b].push(a);
  });
  
  initializeVisualization();
}

// Pan and zoom functionality
function updateTransform() {
  document.getElementById('garden-canvas').style.transform = 
    `translate(${translateX}px, ${translateY}px) scale(${scale})`;
}

function setupPanZoom() {
  const container = document.getElementById('garden-container');
  
  container.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = container.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const pointX = (mouseX - translateX) / scale;
    const pointY = (mouseY - translateY) / scale;
    const zoomFactor = e.deltaY > 0 ? 0.95 : 1.05;
    const newScale = Math.max(0.1, Math.min(5, scale * zoomFactor));
    translateX = mouseX - pointX * newScale;
    translateY = mouseY - pointY * newScale;
    scale = newScale;
    updateTransform();
  });
  
  container.addEventListener('mousedown', (e) => {
    if (e.target === container || e.target.id === 'garden-canvas') {
      isPanning = true;
      lastPanPoint = { x: e.clientX, y: e.clientY };
      container.classList.add('panning');
      e.preventDefault();
    }
  });
  
  document.addEventListener('mousemove', (e) => {
    if (isPanning) {
      const deltaX = e.clientX - lastPanPoint.x;
      const deltaY = e.clientY - lastPanPoint.y;
      translateX += deltaX;
      translateY += deltaY;
      lastPanPoint = { x: e.clientX, y: e.clientY };
      updateTransform();
    }
  });
  
  document.addEventListener('mouseup', () => {
    if (isPanning) {
      isPanning = false;
      container.classList.remove('panning');
    }
  });

  // Touch controls for mobile
  container.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
          isPanning = true;
          lastPanPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          container.classList.add('panning');
      } else if (e.touches.length === 2) {
          isPanning = false; // Stop panning when a second finger is added
          initialPinchDistance = Math.hypot(
              e.touches[0].clientX - e.touches[1].clientX,
              e.touches[0].clientY - e.touches[1].clientY
          );
      }
      e.preventDefault();
  }, { passive: false });

  container.addEventListener('touchmove', (e) => {
      if (e.touches.length === 1 && isPanning) {
          const deltaX = e.touches[0].clientX - lastPanPoint.x;
          const deltaY = e.touches[0].clientY - lastPanPoint.y;
          translateX += deltaX;
          translateY += deltaY;
          lastPanPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          updateTransform();
      } else if (e.touches.length === 2 && initialPinchDistance) {
          const newPinchDistance = Math.hypot(
              e.touches[0].clientX - e.touches[1].clientX,
              e.touches[0].clientY - e.touches[1].clientY
          );

          const rect = container.getBoundingClientRect();
          const touchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
          const touchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;

          const pointX = (touchCenterX - translateX) / scale;
          const pointY = (touchCenterY - translateY) / scale;
          
          const zoomFactor = newPinchDistance / initialPinchDistance;
          const newScale = Math.max(0.1, Math.min(5, scale * zoomFactor));

          translateX = touchCenterX - pointX * newScale;
          translateY = touchCenterY - pointY * newScale;
          scale = newScale;

          initialPinchDistance = newPinchDistance; // Update for continuous zoom
          updateTransform();
      }
      e.preventDefault();
  }, { passive: false });

  container.addEventListener('touchend', (e) => {
      isPanning = false;
      initialPinchDistance = null;
      container.classList.remove('panning');
  });
}

// Create visual elements
function createPlantNodes() {
  const canvas = document.getElementById('garden-canvas');
  plantNodes.forEach(node => node.element.remove());
  plantNodes.length = 0;
  
  Object.entries(plantLabels).forEach(([species, positions]) => {
    positions.forEach(([x, y]) => {
      y = -y; // Y-coordinate is inverted to match Cartesian system
      
      const node = document.createElement('div');
      node.className = 'plant-node';
      node.style.left = `${x}px`;
      node.style.top = `${y}px`;
      node.title = species;
      node.addEventListener('click', (e) => {
        e.stopPropagation();
        selectPlant(species, true);
      });
      node.addEventListener('touchstart', (e) => {
        e.stopPropagation();
        selectPlant(species, true);
      });
      
      canvas.appendChild(node);
      plantNodes.push({ element: node, species, x, y });
    });
  });
}

function createNetworkNodes() {
  const canvas = document.getElementById('garden-canvas');
  networkNodes.forEach(node => node.element.remove());
  networkNodes.length = 0;
  
  Object.entries(networkPositions).forEach(([vertex, position]) => {
    const vertexNum = parseInt(vertex);
    let [x, y] = position;
    y = -y; // Y-coordinate is inverted to match Cartesian system
    
    const node = document.createElement('div');
    node.className = 'network-node';
    node.style.left = `${x}px`;
    node.style.top = `${y}px`;
    node.title = `Network Node ${vertexNum}`;
    node.addEventListener('click', (e) => {
      e.stopPropagation();
      selectNetworkNode(vertexNum);
    });
    node.addEventListener('touchstart', (e) => {
      e.stopPropagation();
      selectNetworkNode(vertexNum);
    });
    
    canvas.appendChild(node);
    networkNodes.push({ element: node, nodeId: vertexNum, x, y });
  });
}

function createConnections() {
  const canvas = document.getElementById('garden-canvas');
  connections.forEach(conn => conn.element.remove());
  connections.length = 0;
  
  edgeList.forEach(([nodeA, nodeB]) => {
    const posA = networkPositions[nodeA.toString()];
    const posB = networkPositions[nodeB.toString()];
    
    if (posA && posB) {
      let [x1, y1] = posA;
      let [x2, y2] = posB;
      y1 = -y1; // Y-coordinate is inverted
      y2 = -y2; // Y-coordinate is inverted
      
      const dx = x2 - x1;
      const dy = y2 - y1;
      const length = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      
      const line = document.createElement('div');
      line.className = 'connection-line';
      line.style.left = `${x1}px`;
      line.style.top = `${y1}px`;
      line.style.width = `${length}px`;
      line.style.transform = `rotate(${angle}deg)`;
      
      canvas.appendChild(line);
      connections.push({ element: line, nodeA, nodeB });
    }
  });
}

function hideLegend() {
    const legend = document.getElementById('legend');
    wasLegendVisible = !legend.classList.contains('hidden') && !legend.classList.contains('mobile-hidden');
    legend.classList.add('hidden');
}

// Selection handlers
function selectPlant(species, isNodeClick = false) {
  // If coloring by category and a node is clicked, show the category panel first.
  if (colorByKey !== 'species' && isNodeClick) {
    displayCategoryPanel(species);
    return;
  }

  // Original logic to display species-specific info
  clearSelections();
  hideLegend();

  const plantInfoEntry = Object.entries(plantData).find(([commonName, data]) => 
      commonName.toLowerCase() === species.toLowerCase() || 
      (data.latin_name && data.latin_name.toLowerCase() === species.toLowerCase())
  );

  const info = plantInfoEntry ? plantInfoEntry[1] : null;
  const commonName = plantInfoEntry ? plantInfoEntry[0] : species;

  const detailsContainer = document.getElementById('plant-info-details');
  const nameEl = document.getElementById('plant-name');
  detailsContainer.innerHTML = '';

  if (info) {
    nameEl.innerHTML = `${commonName} ${info.native ? '<span class="common-name-native">(Native)</span>' : ''}`;
    
    const createInfoGridItem = (label, value, icon) => {
        if (!value) return '';
        return `
            <div class="info-item">
                ${icon}
                <div class="info-item-text">
                    <div class="info-label">${label}</div>
                    <div class="info-content">${value}</div>
                </div>
            </div>
        `;
    };

    const createInfoSection = (title, content) => {
        if (!content) return '';
        return `
            <div class="info-section">
                <h4>${title}</h4>
                <p class="info-content">${content}</p>
            </div>
        `;
    };

    let detailsHTML = `<div class="latin-name">${info.latin_name || 'N/A'}</div>`;
    
    detailsHTML += '<div class="info-grid">';
    detailsHTML += createInfoGridItem('Sun', info.sun, ICONS.sun);
    detailsHTML += createInfoGridItem('Water', info.water, ICONS.water);
    detailsHTML += createInfoGridItem('Height', info.height, ICONS.height);
    detailsHTML += createInfoGridItem('Spread', info.spread, ICONS.spread);
    detailsHTML += createInfoGridItem('Blooms', info.blooming_time, ICONS.bloom);
    detailsHTML += createInfoGridItem('Harvest', info.harvest_time, ICONS.harvest);
    detailsHTML += '</div>';

    detailsHTML += createInfoSection('Edible Use', info.edible_use);
    detailsHTML += createInfoSection('Medicinal Use', info.medicinal_use);
    detailsHTML += createInfoSection('Other Uses', info.other_use);
    
    if (info.toxicity) {
        detailsHTML += createInfoSection('Toxicity', info.toxicity);
    }

    detailsContainer.innerHTML = detailsHTML;
    
    plantNodes.forEach(node => {
      if (node.species === species) {
        node.element.classList.add('selected');
      }
    });
  } else {
    nameEl.textContent = 'Data Not Found';
    detailsContainer.innerHTML = `<p class="info-content">Detailed information for <strong>${species}</strong> could not be found.</p>`;
  }
  document.getElementById('plant-info').classList.add('visible');
  updateScrollIndicator('plant-info', 'plant-info-details');
}

function displayCategoryPanel(species) {
    clearSelections();
    hideLegend();

    const plantInfoEntry = Object.entries(plantData).find(([cn, d]) => 
        cn.toLowerCase() === species.toLowerCase() || (d.latin_name && d.latin_name.toLowerCase() === species.toLowerCase())
    );
    
    if (!plantInfoEntry) return;

    const info = plantInfoEntry[1];
    const categoryValue = info[colorByKey];

    if (categoryValue === undefined || categoryValue === null) {
        selectPlant(species, false); // Fallback to species view if no data for this category
        return;
    }

    highlightFromLegend(colorByKey, categoryValue);

    const detailsContainer = document.getElementById('plant-info-details');
    const nameEl = document.getElementById('plant-name');
    const select = document.getElementById('color-by-select');
    const categoryName = select.options[select.selectedIndex].text;
    const categoryColor = dynamicColorMaps[colorByKey][categoryValue];

    const swatchHTML = `<div class="plant-node" style="background-color: ${categoryColor}; position: relative; left: auto; top: auto; display: inline-block; vertical-align: middle; margin-right: 12px; transform: none; flex-shrink: 0;"></div>`;
    nameEl.innerHTML = `${swatchHTML}<span>${categoryName}: ${categoryValue}</span>`;

    let detailsHTML = `
        <div class="info-content" style="margin-bottom: 16px;">
            You selected <strong>${species}</strong>.
        </div>
        <button class="control-btn" id="view-species-details" style="margin-bottom: 20px;">View Details for ${species}</button>
        <div class="info-label">Other plants in this category:</div>
        <ul class="nearby-species-list">
    `;
    
    const otherPlants = [];
    Object.entries(plantData).forEach(([commonName, data]) => {
        if (String(data[colorByKey]) === String(categoryValue) && commonName !== species) {
            otherPlants.push(commonName);
        }
    });

    if (otherPlants.length > 0) {
        otherPlants.sort().forEach(plantName => {
            detailsHTML += `<li data-species="${plantName}">${plantName}</li>`;
        });
    } else {
        detailsHTML += `<li>None</li>`;
    }
    
    detailsHTML += '</ul>';
    detailsContainer.innerHTML = detailsHTML;

    document.getElementById('view-species-details').onclick = () => {
        selectPlant(species, false);
    };
    detailsContainer.querySelectorAll('.nearby-species-list li[data-species]').forEach(li => {
        li.onclick = () => selectPlant(li.dataset.species, true);
    });

    document.getElementById('plant-info').classList.add('visible');
    updateScrollIndicator('plant-info', 'plant-info-details');
}


// Helper function to find nearby plants
function findNearbyPlants(nodePos) {
    const nearby = { close: {}, far: {} };

    Object.entries(plantLabels).forEach(([species, positions]) => {
        positions.forEach(([plantX, plantY]) => {
            const dx = plantX - nodePos[0];
            const dy = (-plantY) - (-nodePos[1]);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= CLOSE_RADIUS) {
                if (!nearby.close[species] || distance < nearby.close[species]) {
                    nearby.close[species] = distance;
                }
            } else if (distance <= FAR_RADIUS) {
                 if (!nearby.far[species] || distance < nearby.far[species]) {
                    nearby.far[species] = distance;
                }
            }
        });
    });

    const sortSpeciesByDistance = (speciesObj) => {
        return Object.entries(speciesObj)
            .map(([species, distance]) => ({ species, distance }))
            .sort((a, b) => a.distance - b.distance);
    };

    return {
        close: sortSpeciesByDistance(nearby.close),
        far: sortSpeciesByDistance(nearby.far)
    };
}


function selectNetworkNode(nodeId) {
  clearSelections();
  hideLegend();
  selectedNetworkNodeId = nodeId;
  
  const canvas = document.getElementById('garden-canvas');
  const nodePos = networkPositions[nodeId.toString()];

  const createDisk = (radius, className) => {
      const disk = document.createElement('div');
      disk.className = `radius-disk ${className}`;
      disk.style.width = `${radius * 2}px`;
      disk.style.height = `${radius * 2}px`;
      disk.style.left = `${nodePos[0]}px`;
      disk.style.top = `${-nodePos[1]}px`;
      canvas.appendChild(disk);
      radiusDisks.push(disk);
  };

  createDisk(CLOSE_RADIUS, 'close');
  createDisk(FAR_RADIUS, 'far');

  updatePathNodePanelContent(nodeId);

  const connectedIds = adjacencyList[nodeId] || [];
  networkNodes.forEach(node => {
    if (node.nodeId === nodeId || connectedIds.includes(node.nodeId)) {
      node.element.classList.add('highlighted');
    }
  });
  connections.forEach(conn => {
    if (conn.nodeA === nodeId || conn.nodeB === nodeId) {
      conn.element.classList.add('highlighted');
    }
  });
  document.getElementById('plant-info').classList.add('visible');
}

function updatePathNodePanelContent(nodeId) {
    const detailsContainer = document.getElementById('plant-info-details');
    detailsContainer.innerHTML = '';
    
    document.getElementById('plant-name').textContent = `A Moment on the Path`;
    
    const degree = adjacencyList[nodeId] ? adjacencyList[nodeId].length : 0;
    let role = getRandomMessage(pathMessages.degree2);
    if (degree === 1) role = getRandomMessage(pathMessages.degree1);
    else if (degree > 2) role = getRandomMessage(pathMessages.degree3).replace('${degree}', degree);
    
    const poeticContent = document.createElement('div');
    poeticContent.className = 'info-content poetic';
    poeticContent.textContent = role;
    detailsContainer.appendChild(poeticContent);

    const nodePos = networkPositions[nodeId.toString()];
    const nearbyPlants = findNearbyPlants(nodePos);

    const createSpeciesList = (title, speciesList, customClass = '') => {
        if (speciesList.length > 0) {
            const label = document.createElement('div');
            label.className = `info-label ${customClass}`;
            label.textContent = title;
            detailsContainer.appendChild(label);

            const list = document.createElement('ul');
            list.className = 'nearby-species-list';
            speciesList.forEach(plant => {
                const item = document.createElement('li');
                const nodeSwatch = document.createElement('span');
                nodeSwatch.className = 'nearby-species-swatch';

                const plantInfoEntry = Object.entries(plantData).find(([cn, d]) => 
                    cn.toLowerCase() === plant.species.toLowerCase() || 
                    (d.latin_name && d.latin_name.toLowerCase() === plant.species.toLowerCase())
                );
                const info = plantInfoEntry ? plantInfoEntry[1] : null;
                
                let swatchColor = 'rgba(74, 68, 58, 0.1)';

                if (info) {
                    const key = colorByKey;
                    if (key === 'species') {
                        swatchColor = speciesColorMap[plant.species] || swatchColor;
                    } else {
                        const value = info[key];
                        if (value !== undefined && value !== null && dynamicColorMaps[key]) {
                            swatchColor = dynamicColorMaps[key][value] || swatchColor;
                        }
                    }
                }
                nodeSwatch.style.backgroundColor = swatchColor;

                const speciesText = document.createElement('span');
                speciesText.textContent = plant.species;
                item.appendChild(nodeSwatch);
                item.appendChild(speciesText);
                item.onclick = () => selectPlant(plant.species, false); // Go direct to species info from here
                list.appendChild(item);
            });
            detailsContainer.appendChild(list);
        }
    };

    createSpeciesList('Close Companions (within 10ft)', nearbyPlants.close);
    createSpeciesList('Distant Neighbors (10-20ft)', nearbyPlants.far, 'distant-neighbors-label');
    updateScrollIndicator('plant-info', 'plant-info-details');
}

function clearSelections() {
  selectedNetworkNodeId = null;
  document.querySelectorAll('.plant-node').forEach(n => n.classList.remove('selected'));
  document.querySelectorAll('.network-node').forEach(n => n.classList.remove('highlighted'));
  document.querySelectorAll('.connection-line').forEach(c => c.classList.remove('highlighted'));
  document.querySelectorAll('.legend-item').forEach(i => i.classList.remove('highlighted'));
  
  radiusDisks.forEach(disk => disk.remove());
  radiusDisks = [];

  document.getElementById('plant-info').classList.remove('visible', 'is-scrollable');
  
  if (wasLegendVisible) {
      document.getElementById('legend').classList.remove('hidden');
  }
  wasLegendVisible = false; // Reset for next time
}

// Search functionality
function setupSearch() {
  const searchInput = document.getElementById('search-input');
  const resultsContainer = document.getElementById('search-results');

  searchInput.addEventListener('input', (e) => {
    const query = e.target.value.toLowerCase();
    resultsContainer.innerHTML = '';

    if (!query) return;
    
    const matchedSpecies = Object.keys(plantLabels).filter(species => 
      species.toLowerCase().includes(query)
    );
    
    matchedSpecies.forEach(species => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.textContent = species;
        item.addEventListener('click', () => {
            selectPlant(species, false); // Go direct to species info from search
            searchInput.value = '';
            resultsContainer.innerHTML = '';

            const firstPosition = plantLabels[species][0];
            if (firstPosition) {
                const [x, y] = firstPosition;
                translateX = window.innerWidth / 2 - x * scale;
                translateY = window.innerHeight / 2 + y * scale;
                updateTransform();
            }
        });
        resultsContainer.appendChild(item);
    });
  });

  searchInput.addEventListener('blur', () => {
      setTimeout(() => {
          resultsContainer.innerHTML = '';
      }, 150);
  });
}

// Color and Legend Logic
const monthOrder = {
    'January': 1, 'February': 2, 'March': 3, 'April': 4, 'May': 5, 'June': 6,
    'July': 7, 'August': 8, 'September': 9, 'October': 10, 'November': 11, 'December': 12
};

function getSortValues(range) {
    if (!range || typeof range !== 'string' || range.length === 0) {
        return { start: 99, end: 99 };
    }
    const months = range.split('-').map(m => m.trim());
    const start = monthOrder[months[0]] || 99;
    const end = monthOrder[months[months.length - 1]] || start;
    return { start, end };
}


const seasonalBaseColors = {
    winter: { h: 195, s: 53, l: 79 }, // Light Blue
    spring: { h: 120, s: 60, l: 80 }, // Light Green
    summer: { h: 120, s: 39, l: 51 }, // Darker Green
    fall:   { h: 30,  s: 59, l: 61 }  // Brownish Orange
};

function getSeason(monthIndex) {
    if (monthIndex >= 3 && monthIndex <= 5) return 'spring';
    if (monthIndex >= 6 && monthIndex <= 8) return 'summer';
    if (monthIndex >= 9 && monthIndex <= 11) return 'fall';
    return 'winter';
}

function generateSeasonalColor(range) {
    if (!range) return null;
    const { start, end } = getSortValues(range);
    
    if (start === 99) return '#cccccc'; // Default for unknown ranges like "Varies"

    const season = getSeason(start);
    const base = seasonalBaseColors[season];
    const duration = Math.max(0, end - start);
    
    // Adjust lightness based on duration. Longer duration = slightly darker.
    const lightnessShift = duration * 4; 
    const finalLightness = Math.max(20, base.l - lightnessShift);

    return `hsl(${base.h}, ${base.s}%, ${finalLightness}%)`;
}


const customColorPalettes = {
    sun: {
        'Full sun': '#FBBF24', // Amber 400
        'Full sun to partial shade': '#FCD34D', // Amber 300
        'Partial shade': '#A5B4FC', // Indigo 300
        'Partial shade to full shade': '#7DD3FC', // Sky 300
        'Full shade': '#94A3B8' // Slate 400
    },
    water: {
        'Low': '#FDE68A', // Amber 200
        'Dry to medium': '#F59E0B', // Amber 500
        'Medium': '#60A5FA', // Blue 400
        'Medium to wet': '#3B82F6', // Blue 500
        'Wet': '#1E3A8A' // Blue 800
    },
    native: {
        true: '#34D399', // Emerald 400
        false: '#F87171' // Red 400
    },
    category: {
        'Shrubs': '#D8B4FE', // Purple 300
        'Winter-interest Perennials': '#67E8F9', // Cyan 300
        'Herbaceous Perennial': '#86EFAC' // Green 300
    }
};

function generateSpeciesColors() {
    const speciesNames = Object.keys(plantLabels);
    speciesNames.forEach((name, i) => {
        const hue = (i / speciesNames.length) * 360;
        speciesColorMap[name] = `hsl(${hue}, 70%, 60%)`;
    });
}

function generateDynamicColors(key) {
    if (dynamicColorMaps[key]) return;

    if (key === 'blooming_time' || key === 'harvest_time') {
        const values = new Set();
        Object.values(plantData).forEach(plant => {
            if (plant[key]) values.add(plant[key]);
        });
        const colorMap = {};
        values.forEach(value => {
            colorMap[value] = generateSeasonalColor(value);
        });
        dynamicColorMaps[key] = colorMap;
        return;
    }

    if (customColorPalettes[key]) {
        dynamicColorMaps[key] = customColorPalettes[key];
        return;
    }

    const onMapSpecies = new Set(Object.keys(plantLabels));
    const values = new Set();
    Object.entries(plantData).forEach(([commonName, plant]) => {
        if (onMapSpecies.has(commonName) || onMapSpecies.has(plant.latin_name)) {
            if (plant[key] !== undefined && plant[key] !== null) {
                values.add(plant[key]);
            }
        }
    });

    const sortedValues = Array.from(values).sort();
    const colorMap = {};
    sortedValues.forEach((value, i) => {
        const hue = (i / sortedValues.length) * 360;
        colorMap[value] = `hsl(${hue}, 70%, 60%)`;
    });
    dynamicColorMaps[key] = colorMap;
}


function updateNodeColors() {
    const key = colorByKey;
    plantNodes.forEach(node => {
        const plantInfoEntry = Object.entries(plantData).find(([commonName, data]) => 
            commonName.toLowerCase() === node.species.toLowerCase() || 
            (data.latin_name && data.latin_name.toLowerCase() === node.species.toLowerCase())
        );
        const info = plantInfoEntry ? plantInfoEntry[1] : null;
        
        node.element.classList.remove('uncolored');
        node.element.style.backgroundColor = '';

        let color = null; 

        if (info) {
            if (key === 'species') {
                color = speciesColorMap[node.species];
            } else {
                const value = info[key];
                if (value !== undefined && value !== null && dynamicColorMaps[key]) {
                    color = dynamicColorMaps[key][value];
                }
            }
        }

        if (color) {
            node.element.style.backgroundColor = color;
        } else {
            node.element.classList.add('uncolored');
        }
    });
}

function updateLegend() {
    const legendEl = document.getElementById('legend');
    const legendTitle = legendEl.querySelector('h3');
    const legendItemsContainer = document.getElementById('legend-items');
    legendItemsContainer.innerHTML = '';

    const key = colorByKey;
    const select = document.getElementById('color-by-select');
    legendTitle.textContent = select.options[select.selectedIndex].text;

    const createLegendItem = (name, color, type, value) => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.dataset.key = type;
        item.dataset.value = value;
        item.innerHTML = `<div class="legend-color-swatch" style="background: ${color};"></div><span>${name}</span>`;
        item.addEventListener('click', () => highlightFromLegend(type, value));
        legendItemsContainer.appendChild(item);
    };
    
    let colorMap = (key === 'species') ? speciesColorMap : dynamicColorMaps[key];
    let itemCount = 0;

    if (colorMap) {
        const presentValues = new Set();
        if (key !== 'species') {
            plantNodes.forEach(node => {
                const plantInfoEntry = Object.entries(plantData).find(([cn, d]) => 
                    cn.toLowerCase() === node.species.toLowerCase() || 
                    (d.latin_name && d.latin_name.toLowerCase() === node.species.toLowerCase())
                );
                const info = plantInfoEntry ? plantInfoEntry[1] : null;
                if (info && info[key] !== undefined && info[key] !== null) {
                    presentValues.add(String(info[key]));
                }
            });
        }

        let sortedItems = Object.entries(colorMap);
        if (key === 'blooming_time' || key === 'harvest_time') {
            sortedItems.sort((a, b) => {
                const valA = getSortValues(a[0]);
                const valB = getSortValues(b[0]);
                if (valA.start !== valB.start) {
                    return valA.start - valB.start;
                }
                return valA.end - valB.end;
            });
        }

        sortedItems.forEach(([name, color]) => {
            if (key === 'species' || presentValues.has(name)) {
                 createLegendItem(name, color, key, name);
                 itemCount++;
            }
        });
    }

    if (key !== 'species') {
        const hasUncoloredNodes = plantNodes.some(node => node.element.classList.contains('uncolored'));
        if (hasUncoloredNodes) {
            const uncoloredSwatch = 'rgba(74, 68, 58, 0.1)';
            const item = document.createElement('div');
            item.className = 'legend-item';
            item.dataset.key = 'uncolored';
            item.dataset.value = 'uncolored';
            item.innerHTML = `<div class="legend-color-swatch" style="background: ${uncoloredSwatch}; border: 1px solid rgba(74, 68, 58, 0.2);"></div><span>No Data</span>`;
            item.addEventListener('click', () => highlightFromLegend('uncolored', 'uncolored'));
            legendItemsContainer.appendChild(item);
        }
    }

    const MULTI_COLUMN_THRESHOLD = 10;
    legendEl.classList.toggle('multi-column', itemCount > MULTI_COLUMN_THRESHOLD);
}

function highlightFromLegend(key, value) {
  clearSelections();
  document.getElementById('plant-info').classList.remove('visible');

  plantNodes.forEach(node => {
      let match = false;
      if (key === 'uncolored') {
          if (node.element.classList.contains('uncolored')) {
              match = true;
          }
      } else if (key === 'species') {
          match = node.species === value;
      } else {
          const plantInfoEntry = Object.entries(plantData).find(([commonName, data]) => 
              commonName.toLowerCase() === node.species.toLowerCase() || 
              (data.latin_name && data.latin_name.toLowerCase() === node.species.toLowerCase())
          );
          const nodeInfo = plantInfoEntry ? plantInfoEntry[1] : null;

          if (nodeInfo && nodeInfo[key] !== undefined && nodeInfo[key] !== null && String(nodeInfo[key]) === String(value)) {
              match = true;
          }
      }
      if (match) {
        node.element.classList.add('selected');
      }
    });

    document.querySelectorAll('.legend-item').forEach(item => {
        if (item.dataset.key === key && item.dataset.value === String(value)) {
            item.classList.add('highlighted');
        }
    });
}

function populateColorDropdown() {
    const select = document.getElementById('color-by-select');
    const onMapSpecies = new Set(Object.keys(plantLabels));
    let uniqueKeys = new Set();
    const displayNameMap = {
        sun: 'Sun Exposure',
        water: 'Water Needs',
        category: 'Plant Category',
        native: 'Native Status',
        edible_use: 'Edible Use',
        medicinal_use: 'Medicinal Use',
        other_use: 'Other Use',
        toxicity: 'Toxicity',
        blooming_time: 'Blooming Time',
        harvest_time: 'Harvest Time'
    };
    const priorityOrder = ['sun', 'water', 'category', 'native', 'blooming_time', 'harvest_time'];

    Object.entries(plantData).forEach(([commonName, data]) => {
        if (onMapSpecies.has(commonName) || (data.latin_name && onMapSpecies.has(data.latin_name))) {
            Object.keys(data).forEach(key => uniqueKeys.add(key));
        }
    });

    select.innerHTML = '';
    
    const createOption = (value, text) => {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = text;
        select.appendChild(option);
    };

    createOption('species', 'Species');
    
    priorityOrder.forEach(key => {
        if (uniqueKeys.has(key)) {
            createOption(key, displayNameMap[key] || key);
            uniqueKeys.delete(key);
        }
    });

    const remainingKeys = Array.from(uniqueKeys).filter(key => key !== 'latin_name' && key !== 'height' && key !== 'spread').sort();
    remainingKeys.forEach(key => {
        const formattedKey = displayNameMap[key] || (key.charAt(0).toUpperCase() + key.slice(1).replace(/_/g, ' '));
        createOption(key, formattedKey);
    });
}


// Map and Bounding Box Logic
function setupMap() {
    const mapImage = document.getElementById('garden-map');
    mapImage.src = './imgs/sunken-garden-map.png'; 
    mapImage.onload = () => {
        mapImage.style.left = `0px`;
        mapImage.style.top = `-${mapImage.naturalHeight}px`;
        mapImage.style.width = `${mapImage.naturalWidth}px`;
        mapImage.style.height = `${mapImage.naturalHeight}px`;
        mapImage.style.display = 'block';
        centerView(); 
    };
    mapImage.onerror = () => {
        mapImage.src = 'https://placehold.co/1000x800/1e293b/94a3b8?text=Sunken+Garden+Map';
        mapImage.onload = () => { // Recenter after placeholder loads
            mapImage.style.left = `0px`;
            mapImage.style.top = `-${mapImage.naturalHeight}px`;
            mapImage.style.width = `${mapImage.naturalWidth}px`;
            mapImage.style.height = `${mapImage.naturalHeight}px`;
            mapImage.style.display = 'block';
            centerView();
        }
    };
}

function updateScrollIndicator(panelId, contentId) {
    const panel = document.getElementById(panelId);
    const content = document.getElementById(contentId);
    if (!panel || !content) return;
    
    setTimeout(() => {
        if (content.scrollHeight > content.clientHeight) {
            panel.classList.add('is-scrollable');
        } else {
            panel.classList.remove('is-scrollable');
        }
    }, 150);
}


// Initialize everything
function initializeVisualization() {
  console.log('Initializing visualization...');
  
  populateColorDropdown();
  generateSpeciesColors();
  
  const allKeys = new Set();
  Object.values(plantData).forEach(plant => Object.keys(plant).forEach(k => allKeys.add(k)));
  allKeys.forEach(key => generateDynamicColors(key));

  setupPanZoom();
  createPlantNodes();
  createNetworkNodes();
  createConnections();
  setupMap();
  setupSearch();
  updateNodeColors(); 
  updateLegend();
  
  console.log('Visualization initialized successfully');
}

// Center the view
function centerView() {
  const mapImage = document.getElementById('garden-map');
  const imageWidth = mapImage.naturalWidth || 1000; // Fallback width
  const imageHeight = mapImage.naturalHeight || 800; // Fallback height

  const centerX = imageWidth / 2;
  const centerY = -imageHeight / 2;

  const availableWidth = window.innerWidth;
  const availableHeight = window.innerHeight;

  const scaleX = availableWidth / imageWidth;
  const scaleY = availableHeight / imageHeight;
  scale = Math.min(scaleX, scaleY) * 0.9;

  translateX = (availableWidth / 2) - (centerX * scale);
  translateY = (availableHeight / 2) - (centerY * scale);
  
  updateTransform();
}

// DOM Ready Event Listeners
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM loaded, starting application...');
  
  const headerContainer = document.getElementById('header-container');
  const mobileMenuToggle = document.getElementById('mobile-menu-toggle');
  const legendToggle = document.getElementById('legend-toggle');
  const legend = document.getElementById('legend');
  const colorSelect = document.getElementById('color-by-select');
  const tutorialOverlay = document.getElementById('tutorial-overlay');
  const closeTutorialBtn = document.getElementById('close-tutorial');
  const aboutOverlay = document.getElementById('about-overlay');
  const aboutBtn = document.getElementById('about-btn');
  const closeAboutBtn = document.getElementById('close-about');
  const tutorialList = tutorialOverlay.querySelector('ul');
  const legendMinifyToggle = document.getElementById('legend-minify-toggle');

  const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

  if (isTouchDevice) {
      const panZoomLi = tutorialList.querySelector('li');
      if (panZoomLi) {
          panZoomLi.innerHTML = '<strong>Pan & Zoom:</strong> Drag with one finger to move the map. Pinch with two fingers to zoom.';
      }
  }

  tutorialOverlay.classList.add('visible');
  closeTutorialBtn.onclick = () => tutorialOverlay.classList.remove('visible');
  aboutBtn.onclick = () => aboutOverlay.classList.add('visible');
  closeAboutBtn.onclick = () => aboutOverlay.classList.remove('visible');
  mobileMenuToggle.onclick = () => headerContainer.classList.toggle('menu-open');
  legendToggle.onclick = () => legend.classList.toggle('mobile-hidden');
  legendMinifyToggle.onclick = () => legend.classList.toggle('minified');

  if (window.innerWidth <= 768) {
      legend.classList.add('mobile-hidden');
  }

  document.getElementById('reset-view').onclick = () => {
    centerView();
    clearSelections();
  };

  colorSelect.onchange = (e) => {
    clearSelections();
    colorByKey = e.target.value;
    updateNodeColors();
    updateLegend();
    if (selectedNetworkNodeId) {
        updatePathNodePanelContent(selectedNetworkNodeId);
    }
  };

  document.getElementById('toggle-map').onchange = (e) => {
      document.body.classList.toggle('map-hidden', !e.target.checked);
      document.getElementById('garden-map').classList.toggle('hidden', !e.target.checked);
  };

  document.getElementById('toggle-paths').onchange = (e) => {
      document.body.classList.toggle('paths-hidden', !e.target.checked);
  };

  document.getElementById('toggle-plants').onchange = (e) => {
      document.body.classList.toggle('plants-hidden', !e.target.checked);
  };

  document.getElementById('close-info').onclick = () => {
    clearSelections();
  };
  
  loadData();
});
</script>
</body>
</html>
